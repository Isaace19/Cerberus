How the challenge works:

given a 2D matrix, can we find out which values are negative?

hint: use binary search or brute force a method to find it all. 
This is because if the matrix is sorting like it is in this scenario, than we can just use a binary search.

using the stl binary search, or an implementation allows us to look for all values inside
a range that might satisfy our criteria, this case a negative number.

In the case of the stl binary search, it uses upper and lower bounds

looking at our solution:

rbegin and rend are reverse stl function


class Solution {
public:
    int countNegatives(std::vector<std::vector<int>>& grid) {
		int total = 0;
		int n = grid.size();
		for(int i = 0; i<n; i++){
			int l1 = upper_bound(grid[i].rbegin(), grid[i], grid[i].rend(), -1) - grid[i].rbegin();
			total+=l1;
		}		
		return total;
	}+
};

we have an empty total to keep tally of the negatives we find, an an int n of the grid's size for for loop searching. 

What is happening here with the int l1 upper_bound is essentially searching the beginning and end of the grid, rbeing and rend of grid[i].
can the criteria is the -1 - grid[i].rbegin();

and than we can append this l1 value to the int total set to 0
